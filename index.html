<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Mini Wordle — EN</title>
    <style>
      :root {
        --bg: #111;
        --panel: #161616;
        --tile: #222;
        --border: #444;
        --w: 60px;
        --gap: 8px;
        --modal-bg: rgba(0, 0, 0, 0.75);
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--bg);
        color: #fff;
        font-family: Inter, system-ui, Roboto, "Helvetica Neue", Arial;
        padding: 20px;
      }

      /* top-right TR button */
      .top-right {
        position: fixed;
        top: 12px;
        right: 12px;
        z-index: 1000;
      }
      .lang-btn {
        background: #222;
        color: #fff;
        border: 1px solid rgba(255, 255, 255, 0.06);
        padding: 8px 10px;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 700;
      }
      .lang-btn:hover {
        filter: brightness(1.15);
      }

      .app {
        width: max-content;
        display: flex;
        flex-direction: column;
        gap: 18px;
        align-items: center;
      }
      h1 {
        margin: 0;
        font-size: 20px;
        font-weight: 600;
      }

      .board {
        display: grid;
        gap: var(--gap);
        background: transparent;
      }
      .row {
        display: grid;
        grid-template-columns: repeat(5, var(--w));
        gap: var(--gap);
      }
      .cell {
        width: var(--w);
        height: var(--w);
        background: var(--tile);
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 26px;
        font-weight: 700;
        letter-spacing: 2px;
        text-transform: uppercase;
        border: 2px solid var(--border);
        transform-style: preserve-3d;
        backface-visibility: hidden;
        position: relative;
        user-select: none;
      }
      .cell.active {
        box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.04) inset;
        border-color: #999;
      }

      .cell.flip {
        animation: flip 600ms cubic-bezier(0.2, 0.9, 0.3, 1) forwards;
      }
      @keyframes flip {
        0% {
          transform: rotateX(0deg);
        }
        50% {
          transform: rotateX(90deg);
        }
        100% {
          transform: rotateX(0deg);
        }
      }

      .cell.correct {
        background: #538d4e;
        border-color: #538d4e;
        color: #fff;
      }
      .cell.present {
        background: #b59f3b;
        border-color: #b59f3b;
        color: #fff;
      }
      .cell.absent {
        background: #3a3a3c;
        border-color: #3a3a3c;
        color: #fff;
      }

      .keyboard {
        display: flex;
        flex-direction: column;
        gap: 8px;
        width: 100%;
        align-items: center;
      }
      .key-row {
        display: flex;
        gap: 8px;
        justify-content: center;
      }
      .key {
        min-width: 40px;
        padding: 10px 12px;
        background: #555;
        border-radius: 6px;
        border: none;
        color: #fff;
        font-weight: 700;
        cursor: pointer;
        user-select: none;
        transform: translateZ(0);
      }
      .key.small {
        min-width: 64px;
        padding: 8px 10px;
      }
      .key.absent {
        background: #3a3a3c;
      }
      .key.present {
        background: #b59f3b;
      }
      .key.correct {
        background: #538d4e;
      }

      #msg {
        min-height: 22px;
        font-size: 14px;
        color: #ddd;
        text-align: center;
      }

      /* modal */
      .modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: var(--modal-bg);
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.18s ease, visibility 0.18s;
        z-index: 999;
      }
      .modal.show {
        visibility: visible;
        opacity: 1;
      }
      .panel {
        background: #121212;
        border-radius: 12px;
        padding: 20px;
        width: 360px;
        text-align: center;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.04);
      }
      .panel h2 {
        margin: 0 0 8px 0;
        font-size: 20px;
      }
      .panel p {
        margin: 8px 0 16px 0;
        color: #ddd;
      }
      .panel .actions {
        display: flex;
        gap: 10px;
        justify-content: center;
      }
      .btn {
        padding: 10px 14px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        font-weight: 700;
      }
      .btn.primary {
        background: #538d4e;
        color: #fff;
      }
      .btn.ghost {
        background: transparent;
        color: #fff;
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      @media (max-width: 480px) {
        :root {
          --w: 48px;
          --gap: 6px;
        }
        .key {
          min-width: 34px;
          padding: 8px 8px;
          font-size: 13px;
        }
        .panel {
          width: 92%;
        }
      }
    </style>
  </head>
  <body>
    <!-- top-right language button -->
    <div class="top-right">
      <button class="lang-btn" id="trBtn" title="Türkçe sayfaya geç">TR</button>
    </div>

    <div class="app" id="app">
      <h1>Mini Wordle — English</h1>
      <div class="board" id="board" aria-hidden="false"></div>
      <div id="msg"></div>
      <div class="keyboard" id="keyboard" aria-hidden="false"></div>
    </div>

    <!-- modal -->
    <div
      class="modal"
      id="endModal"
      role="dialog"
      aria-modal="true"
      aria-hidden="true"
    >
      <div class="panel" id="endPanel">
        <h2 id="endTitle">Result</h2>
        <p id="endText">...</p>
        <div class="actions">
          <button class="btn primary" id="replayBtn">Play Again</button>
        </div>
      </div>
    </div>

    <script>
      /* CONFIG */
      const WORD_LENGTH = 5;
      const MAX_ROWS = 5;
      const RANDOM_WORD_API =
        "https://random-word-api.herokuapp.com/word?number=1&length=5";
      const FALLBACK_WORDS = [
        "APPLE",
        "CRANE",
        "LIGHT",
        "BRAVE",
        "SOUND",
        "POINT",
        "STORE",
      ];

      /* STATE */
      let target = "";
      let currentRow = 0;
      let currentCol = 0;
      let busy = false;
      let isComposing = false;
      const boardEl = document.getElementById("board");
      const keyboardEl = document.getElementById("keyboard");
      const msgEl = document.getElementById("msg");
      const modal = document.getElementById("endModal");
      const endTitle = document.getElementById("endTitle");
      const endText = document.getElementById("endText");
      const replayBtn = document.getElementById("replayBtn");
      const trBtn = document.getElementById("trBtn");

      // English QWERTY
      const layout = ["QWERTYUIOP", "ASDFGHJKL", "ZXCVBNM"];

      /* create board */
      const grid = [];
      for (let r = 0; r < MAX_ROWS; r++) {
        const row = document.createElement("div");
        row.className = "row";
        boardEl.appendChild(row);
        const cells = [];
        for (let c = 0; c < WORD_LENGTH; c++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          row.appendChild(cell);
          cells.push(cell);
        }
        grid.push(cells);
      }

      /* create keyboard */
      const keyMap = {};
      layout.forEach((line, idx) => {
        const row = document.createElement("div");
        row.className = "key-row";
        if (idx === 2) {
          const ent = document.createElement("button");
          ent.className = "key small";
          ent.id = "enterKey";
          ent.textContent = "ENTER";
          ent.onclick = submit;
          row.appendChild(ent);
        }
        for (const ch of line) {
          const btn = document.createElement("button");
          btn.className = "key";
          btn.textContent = ch;
          btn.onclick = () => handleLetter(ch);
          row.appendChild(btn);
          keyMap[ch] = btn;
        }
        if (idx === 2) {
          const del = document.createElement("button");
          del.className = "key small";
          del.id = "delKey";
          del.textContent = "⌫";
          del.onclick = handleBackspace;
          row.appendChild(del);
        }
        keyboardEl.appendChild(row);
      });

      updateActive();

      /* fetch random english 5-letter word from API */
      async function fetchTargetFromApi() {
        try {
          const res = await fetch(RANDOM_WORD_API);
          if (!res.ok) throw new Error("api fail");
          const arr = await res.json();
          if (!Array.isArray(arr) || !arr[0]) throw new Error("bad payload");
          target = String(arr[0]).toUpperCase();
          // ensure it's 5 letters; if not, use fallback or retry a few times
          if (!/^[A-Z]{5}$/.test(target)) {
            // try a few times quickly
            for (let i = 0; i < 3 && !/^[A-Z]{5}$/.test(target); i++) {
              const r2 = await fetch(RANDOM_WORD_API);
              const a2 = await r2.json();
              target = String(a2[0] || "").toUpperCase();
            }
            if (!/^[A-Z]{5}$/.test(target))
              throw new Error("no valid 5-letter from api");
          }
        } catch (e) {
          console.warn("API failed, using fallback:", e);
          target =
            FALLBACK_WORDS[Math.floor(Math.random() * FALLBACK_WORDS.length)];
        }
        console.log("Target (chosen):", target);
        msgEl.textContent =
          "Type or use the on-screen keyboard. Press ENTER to submit.";
      }
      fetchTargetFromApi();

      /* helpers */
      function setMsg(t) {
        msgEl.textContent = t;
      }
      function updateActive() {
        grid.flat().forEach((cell) => cell.classList.remove("active"));
        if (currentRow < MAX_ROWS)
          grid[currentRow][currentCol]?.classList.add("active");
      }

      /* input handlers (English letters only) */
      const singleLetterRegex = /^[A-Za-z]$/;
      function handleLetter(letter) {
        if (busy) return;
        if (currentRow >= MAX_ROWS) return;
        if (!singleLetterRegex.test(letter)) return;
        const cell = grid[currentRow][currentCol];
        cell.textContent = letter.toUpperCase();
        if (currentCol < WORD_LENGTH - 1) currentCol++;
        updateActive();
      }

      function handleBackspace() {
        if (busy) return;
        if (currentRow >= MAX_ROWS) return;
        if (grid[currentRow][currentCol].textContent === "" && currentCol > 0)
          currentCol--;
        grid[currentRow][currentCol].textContent = "";
        updateActive();
      }

      /* physical keyboard */
      document.addEventListener("keydown", (e) => {
        if (isComposing) return;
        if (busy) return;
        const k = e.key;
        if (k === "Enter") {
          e.preventDefault();
          submit();
          return;
        }
        if (k === "Backspace") {
          e.preventDefault();
          handleBackspace();
          return;
        }
        if (k.length === 1 && singleLetterRegex.test(k)) {
          e.preventDefault();
          handleLetter(k.toUpperCase());
        }
      });
      document.addEventListener("compositionstart", () => (isComposing = true));
      document.addEventListener("compositionend", () => (isComposing = false));

      /* submit guess logic */
      const wordRegex = /^[A-Z]{5}$/;
      function submit() {
        if (busy) return;
        if (currentRow >= MAX_ROWS) return;
        const guess = grid[currentRow].map((c) => c.textContent || "").join("");
        if (guess.length < WORD_LENGTH) {
          setMsg("Fill all letters!");
          return;
        }
        if (!wordRegex.test(guess)) {
          setMsg("Only A-Z letters allowed.");
          return;
        }

        busy = true;
        setMsg("");
        const guessArr = guess.split("");
        const targetArr = target.split("");

        const freq = {};
        for (let i = 0; i < targetArr.length; i++) {
          const ch = targetArr[i];
          freq[ch] = (freq[ch] || 0) + 1;
        }

        const status = Array(WORD_LENGTH).fill("absent");
        for (let i = 0; i < WORD_LENGTH; i++) {
          if (guessArr[i] === targetArr[i]) {
            status[i] = "correct";
            freq[guessArr[i]] = Math.max((freq[guessArr[i]] || 1) - 1, 0);
          }
        }
        for (let i = 0; i < WORD_LENGTH; i++) {
          if (status[i] === "correct") continue;
          const ch = guessArr[i];
          if ((freq[ch] || 0) > 0) {
            status[i] = "present";
            freq[ch]--;
          } else {
            status[i] = "absent";
          }
        }

        const REVEAL_DELAY = 300;
        for (let i = 0; i < WORD_LENGTH; i++) {
          const cell = grid[currentRow][i];
          setTimeout(() => cell.classList.add("flip"), i * REVEAL_DELAY);
          setTimeout(() => {
            cell.classList.add(status[i]);
            updateKeyboard(guessArr[i], status[i]);
          }, i * REVEAL_DELAY + 300);
        }

        setTimeout(() => {
          for (let i = 0; i < WORD_LENGTH; i++) {
            grid[currentRow][i].classList.remove("flip");
            grid[currentRow][i].classList.remove("active");
          }
          const won = status.every((s) => s === "correct");
          const attemptsUsed = currentRow + 1;
          if (won) {
            showEndMenu(true, attemptsUsed);
            busy = true;
            currentRow = MAX_ROWS;
            return;
          }
          currentRow++;
          currentCol = 0;
          if (currentRow >= MAX_ROWS) {
            showEndMenu(false, attemptsUsed);
            busy = true;
          } else {
            updateActive();
            setMsg("Try again.");
          }
          busy = false;
        }, WORD_LENGTH * REVEAL_DELAY + 350);
      }

      /* update keyboard colors (priority correct > present > absent) */
      function updateKeyboard(letter, newStatus) {
        const btn = keyMap[letter.toUpperCase()];
        if (!btn) return;
        if (btn.classList.contains("correct")) return;
        if (newStatus === "correct") {
          btn.classList.remove("present", "absent");
          btn.classList.add("correct");
        } else if (newStatus === "present") {
          if (!btn.classList.contains("present")) {
            btn.classList.remove("absent");
            btn.classList.add("present");
          }
        } else if (newStatus === "absent") {
          if (
            !btn.classList.contains("present") &&
            !btn.classList.contains("correct")
          )
            btn.classList.add("absent");
        }
      }

      /* modal show/hide & reset */
      function showEndMenu(won, attempts) {
        if (won) {
          endTitle.textContent = "Congratulations!";
          endText.textContent = `You guessed the word in ${attempts} ${
            attempts === 1 ? "try" : "tries"
          }.`;
        } else {
          endTitle.textContent = "Game Over";
          endText.textContent = `The word was: ${target}. Attempts: ${attempts}`;
        }
        modal.classList.add("show");
        modal.setAttribute("aria-hidden", "false");
      }
      function hideEndMenu() {
        modal.classList.remove("show");
        modal.setAttribute("aria-hidden", "true");
      }

      async function resetGame() {
        // clear grid
        for (let r = 0; r < MAX_ROWS; r++) {
          for (let c = 0; c < WORD_LENGTH; c++) {
            const cell = grid[r][c];
            cell.textContent = "";
            cell.className = "cell";
          }
        }
        // clear keyboard classes
        for (const k in keyMap) keyMap[k].className = "key";
        currentRow = 0;
        currentCol = 0;
        busy = false;
        hideEndMenu();
        await fetchTargetFromApi();
        updateActive();
      }

      // modal buttons
      replayBtn.addEventListener("click", resetGame);

      /* clicking board to set col */
      boardEl.addEventListener("click", (e) => {
        if (busy) return;
        const cell = e.target.closest(".cell");
        if (!cell) return;
        for (let r = 0; r < MAX_ROWS; r++) {
          const idx = grid[r].indexOf(cell);
          if (idx !== -1) {
            if (r === currentRow) {
              currentCol = idx;
              updateActive();
            }
            return;
          }
        }
      });

      /* TR button navigation */
      trBtn.addEventListener("click", () => {
        // navigate to tr.html (must exist in same folder)
        window.location.href = "tr.html";
      });
    </script>
  </body>
</html>
<a
  href="https://github.com/Whydll/mini-wordle"
  target="_blank"
  class="whydll-link"
  title="GitHub'da Whydll / mini-wordle"
>
  Whydll
</a>

<style>
  .whydll-link {
    position: fixed;
    bottom: 12px;
    left: 14px;
    color: #9c8282;
    font-family: Inter, system-ui, Roboto, "Helvetica Neue", Arial;
    font-size: 14px;
    font-weight: 600;
    text-decoration: none;
    opacity: 0.65;
    transition: opacity 0.2s ease, color 0.2s ease;
  }
  .whydll-link:hover {
    color: #fff;
    opacity: 1;
  }
</style>
